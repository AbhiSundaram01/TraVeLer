"""Functions for operating with and on chains."""

import torch
import torch.nn as nn


def discretize_chain(chain, d):
    """Discretize a chain.

    Parameters
    ----------
    chain : numpy array
        A chain in R^n, represented as a numpy array of shape (p-1,2,n),
        where p is the number of points in the path.

    d : int
        The number of points in the discretized chain

    Returns
    -------
    numpy array
        A discretized chain in R^n, represented as a numpy array of
        shape (p-1,d,n), where p is the number of points in the path.
    """
    r = chain.shape[0]
    n = chain.shape[2]

    d_chain = torch.zeros((r, d, n))
    t = torch.linspace(0, 1, d)

    for i in range(d):
        d_chain[:, i, :] = (1 - t[i]) * chain[:, 0, :] + t[i] * chain[:, 1, :]

    return d_chain


def generate_integration_matrix(form, chain, d=5):
    """Generate the integration matrix from a chain and a 1-form.

    This is the main entry point for generating an integration matrix,
    containing the integrals of a set of 1-forms along some chains.

    Parameters
    ----------
    form : a Pytorch Sequential object
        The 1-form, i.e. vector field to be applied to the chain. Notice
        that the 1-form results in multiple cochains being represented.

    chain : a torch tensor of shape (r,2,n)
        The chain to be turned into a cochain data matrix.

    d : int
        The number of steps for the discretization of the chain.

    Returns
    -------
    torch.tensor of shape (r,c)
        The integration matrix, with `r` representing the number of
        simplices in the chain, and `c` referring to the number of
        cochains generated by `form`.
    """
    # Discretise chain to ensure that it has `d` points.
    chain = discretize_chain(chain, d)

    # Number of simplices
    r = chain.shape[0]

    # Number of points in the chain
    d = chain.shape[1]

    # Dimension of the ambient space
    n = chain.shape[2]

    # Number of feature cochains that are generated by the 1-form.
    if isinstance(form, nn.Sequential):
        c = int(form[-1].out_features / n)
    else:
        c = form.num_cochains

    # Apply the one-form to the discretized chain. This corresponds to
    # an evaluation of the one-form according to the chain data. After
    # this, we reshape it into the right tensor ensuring sure that the
    # number of cochains `c` has its own dimension.
    out = form(chain).reshape((r, d, n, c))

    # Calculate gradients of the chain along each simplex.
    simplex_grad = chain[:, 1, :] - chain[:, 0, :]

    # Swap dimensions n and c in out
    out = out.permute(0, 1, 3, 2)

    # Calculate the inner product of the one form (i.e. the vector field)
    # and the simplex gradients at all steps on each simplex.
    inner_prod = torch.matmul(out, simplex_grad.T / (d - 1))
    # examine inner_prod during the training loop
    # print(f"inner_prod shape: {inner_prod.shape}")
    # print(f"inner_prod min/max/mean: {inner_prod.min():.4f}/{inner_prod.max():.4f}/{inner_prod.mean():.4f}")
    # print(inner_prod)

    # Take diagonal of out3 along axis 0 and 3 (this corresponds to
    # correcting the broadcasted multiplication effect)
    inner_prod = torch.diagonal(inner_prod, dim1=0, dim2=3)

    # Permute dimensions 0 and 2 of out
    inner_prod = inner_prod.permute(2, 0, 1)

    # Apply the trapezoidal rule to the inner product
    cdm = (inner_prod[:, 1:, :] + inner_prod[:, 0:-1, :]) / 2
    cdm = cdm.sum(axis=1)

    return cdm

def component_wise_integration(vf, chain):
    """
    Process each edge in the chain separately through generate_integration_matrix
    and return ensemble results.
    
    Parameters:
    -----------
    vf : nn.Sequential
        The vector field model
    chain : torch.Tensor
        Chain tensor with shape [num_edges, 2, feature_dim]
        
    Returns:
    --------
    dict: Dictionary containing different ensemble methods (sum, mean, max)
    """
    # List to store individual edge results
    edge_results = []
    edge_X_sums = []
    
    # Process each edge separately
    for i in range(chain.shape[0]):
        # Extract a single edge as a mini-chain with shape [1, 2, feature_dim]
        edge_chain = chain[i:i+1]
        
        # Process this edge through generate_integration_matrix
        X_edge = generate_integration_matrix(vf, edge_chain)
        edge_results.append(X_edge)
        
        # Also track the sum for each edge
        edge_X_sums.append(torch.sum(X_edge).item())
    
    # Convert list of tensors to a single tensor
    X_combined = torch.stack(edge_results)
    
    # Return various ensemble methods
    return {
        'individual': edge_results,
        'sums': edge_X_sums,
        'mean_integration': X_combined.mean(dim=0),
        'sum_integration': X_combined.sum(dim=0),
        'max_integration': X_combined.max(dim=0)[0],
        'combined_tensor': X_combined
    }

def equal_contribution_integration(vf, chain):
    """Integration with equal contribution from each edge"""
    # Process each edge separately
    edge_results = []
    
    for i in range(chain.shape[0]):
        # Extract single edge
        edge_chain = chain[i:i+1]
        
        # Get integration for this edge
        X_edge = generate_integration_matrix(vf, edge_chain)
        
        # Normalize by edge length to account for differently sized edges
        edge_length = torch.norm(edge_chain[0, 1] - edge_chain[0, 0])
        normalized_X_edge = X_edge / edge_length
        
        edge_results.append(normalized_X_edge)
    
    # Stack tensors
    X_combined = torch.stack(edge_results)
    
    # Get the mean contribution (each edge now has equal weight)
    X_mean = torch.mean(X_combined, dim=0)
    
    return {
        'individual': edge_results,
        'normalized': X_combined,
        'equal_contribution': X_mean
    }

def weighted_integration(vf, chain):
    """Weight the integration inversely to edge properties"""
    # Calculate edge lengths
    edge_lengths = torch.norm(chain[:, 1] - chain[:, 0], dim=1)
    
    # Create weights inversely proportional to edge length
    # So shorter edges get more weight to balance with longer ones
    weights = 1.0 / (edge_lengths + 1e-6)
    weights = weights / weights.sum()  # Normalize to sum to 1
    
    # Process each edge with its weight
    weighted_results = []
    
    for i in range(chain.shape[0]):
        edge_chain = chain[i:i+1]
        X_edge = generate_integration_matrix(vf, edge_chain)
        weighted_X = X_edge * weights[i]
        weighted_results.append(weighted_X)
    
    # Sum the weighted results
    X_balanced = torch.sum(torch.stack(weighted_results), dim=0)
    
    return X_balanced